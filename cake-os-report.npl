/*
    This program was automatically generated from
    the organisation specification 'cake'
    on marzo 17, 2020 - 09:59:08

    This is a MOISE tool, see more at http://moise.sourceforge.net

*/

scope organisation(cake) {


   // Role hierarchy
   subrole(baker,soc).
   subrole(apprentice,soc).
   subrole(customer,soc).

   // f* rules implement the role hierarchy transitivity
   // t* rules implement the transitivity of some relations

   // fplay(A,R,G) is true if A play R in G or if A play a subrole of R in G
   fplay(A,R,G) :- play(A,R,G).
   fplay(A,R,G) :- subrole(R1,R) & fplay(A,R1,G).

   // fcompatible(R1,R2,S) is true if R1 or its sub-roles are compatible with R2 in scope S
   fcompatible(R1,R2,S) :- tsubrole(R1,R2).
   fcompatible(R1,R2,S) :- tsubrole(R1,R1a) & tsubrole(R2,R2a) & compatible(R1a,R2a,S).
   fcompatible(R1,R2,S) :- tcompatible(R1,R2,S,[R1,R2]).
   tcompatible(R1,R2,S,Path) :- compatible(R1,R3,S) & not .member(R3,Path) & tcompatible(R3,R2,S,[R3|Path]).
   tsubrole(R,R).
   tsubrole(R1,R2)    :- subrole(R1,R2).
   tsubrole(R1,R2)    :- subrole(R1,R3) & tsubrole(R3,R2).


scope group(bakery) {

   // ** Facts from OS
   role_cardinality(baker,1,1).
   role_cardinality(apprentice,1,1).
   role_cardinality(customer,1,1).


   // ** Rules
   rplayers(R,G,V)    :- .count(play(_,R,G),V).
   well_formed(G) :-
      rplayers(baker,G,Vbaker) & Vbaker >= 1 & Vbaker <= 1 &
      rplayers(apprentice,G,Vapprentice) & Vapprentice >= 1 & Vapprentice <= 1 &
      rplayers(customer,G,Vcustomer) & Vcustomer >= 1 & Vcustomer <= 1 &
      .findall(GInst, subgroup(GInst,_,G), ListSubgroups) & all_subgroups_well_formed(ListSubgroups).
   all_subgroups_well_formed([]).
   all_subgroups_well_formed([H|T]) :- subgroup_well_formed(H) & all_subgroups_well_formed(T).

   // ** Properties check 
   norm role_in_group:  
           play(Agt,R,Gr) &
           group_id(Gr) &
           not role_cardinality(R,_,_)
        -> fail(role_in_group(Agt,R,Gr)).
   norm role_cardinality:  
           group_id(Gr) &
           role_cardinality(R,_,RMax) &
           rplayers(R,Gr,RP) &
           RP > RMax
        -> fail(role_cardinality(R,Gr,RP,RMax)).
   norm role_compatibility:  
           play(Agt,R1,Gr) &
           play(Agt,R2,Gr) &
           group_id(Gr) &
           R1 < R2 &
           not fcompatible(R1,R2,gr_inst)
        -> fail(role_compatibility(R1,R2,Gr)).
   norm well_formed_responsible:  
           responsible(Gr,S) &
           not well_formed(Gr)
        -> fail(well_formed_responsible(Gr)).
   norm subgroup_in_group:  
           group_id(Gr) &
           subgroup(G,GT,Gr) &
           not subgroup_cardinality(GT,_,_)
        -> fail(subgroup_in_group(G,GT,Gr)).
   norm subgroup_cardinality:  
           group_id(Gr) &
           subgroup_cardinality(SG,_,SGMax) &
           .count(subgroup(_,SG,Gr),SGP) &
           SGP > SGMax
        -> fail(subgroup_cardinality(SG,Gr,SGP,SGMax)).
} // end of group bakery

scope scheme(cake_sch) {

   // ** Facts from OS

   // mission_cardinality(mission id, min, max)
   mission_cardinality(mBaker,1,1).
   mission_cardinality(mCustomer,1,1).
   mission_cardinality(mApprentice,1,1).

   // mission_role(mission id, role id)
   mission_role(mCustomer,customer).
   mission_role(mApprentice,apprentice).
   mission_role(mBaker,baker).

   // mission_goal(mission id, goal id)
   mission_goal(mBaker,sellCake).
   mission_goal(mBaker,provideAmount).
   mission_goal(mBaker,takePayment).
   mission_goal(mBaker,deliverCake).
   mission_goal(mBaker,prepareCake).
   mission_goal(mBaker,explainIngredients).
   mission_goal(mCustomer,giveToMySon).
   mission_goal(mCustomer,prepareCardOrCash).
   mission_goal(mCustomer,provideMoney).
   mission_goal(mCustomer,eatMyself).
   mission_goal(mApprentice,mixIngredients).
   mission_goal(mApprentice,collectIngredients).
   mission_goal(mApprentice,bakeCake).
   mission_goal(mApprentice,confirmIngredients).

   // report(report id, condition)
   report(ingredients,satisfied(cake_sch,prepareCake)).
   report(amount,satisfied(cake_sch,prepareCake)).
   report(confirmationIngredients,satisfied(cake_sch,collectIngredients)).

   // treatment(treatment id, report id)
   treatment(askConfirmationIngredients,confirmationIngredients).
   treatment(askIngredients,ingredients).
   treatment(askAmount,amount).

   // mission_report(mission id, report id)
   mission_report(mBaker,ingredients).
   mission_report(mBaker,amount).
   mission_report(mApprentice,confirmationIngredients).

   // report_goal(report id, goal id)
   report_goal(ingredients,explainIngredients).
   report_goal(amount,provideAmount).
   report_goal(confirmationIngredients,confirmIngredients).

   // mission_treatment(mission id, treatment id)
   mission_treatment(mBaker,askConfirmationIngredients).
   mission_treatment(mCustomer,askIngredients).
   mission_treatment(mCustomer,askAmount).

   // treatment_goal(treatment id, goal id)
   treatment_goal(askAmount,prepareCardOrCash).

   // goal(missions, goal id, dependence (on goal statisfaction), type, #ags to satisfy, ttf)
   goal([mApprentice],collectIngredients,dep(and,[]),performance,all,`1 year`).
   goal([mApprentice],bakeCake,dep(and,[mixIngredients]),performance,all,`1 year`).
   goal([mBaker],prepareCake,dep(and,[bakeCake]),performance,all,`1 year`).
   goal([mBaker],takePayment,dep(and,[provideMoney]),performance,all,`1 year`).
   goal([mApprentice],confirmIngredients,dep(and,[]),reporting,all,`1 year`).
   goal([mCustomer],prepareCardOrCash,dep(and,[]),treatment,all,`1 year`).
   goal([],produceAndEatCake,dep(and,[eatCake]),performance,0,`1 year`).
   goal([],eatCake,dep(or,[giveToMySon, eatMyself]),performance,0,`1 year`).
   goal([mApprentice],mixIngredients,dep(and,[collectIngredients]),performance,all,`1 year`).
   goal([mBaker],sellCake,dep(and,[deliverCake]),performance,all,`1 year`).
   goal([mBaker],provideAmount,dep(and,[]),reporting,all,`1 year`).
   goal([mBaker],deliverCake,dep(and,[takePayment]),performance,all,`1 year`).
   goal([mCustomer],giveToMySon,dep(and,[sellCake]),performance,all,`1 year`).
   goal([mCustomer],provideMoney,dep(and,[prepareCake]),performance,all,`1 year`).
   goal([mCustomer],eatMyself,dep(and,[sellCake]),performance,all,`1 year`).
   goal([mBaker],explainIngredients,dep(and,[]),reporting,all,`1 year`).
   super_goal(prepareCake, collectIngredients).
   super_goal(prepareCake, bakeCake).
   super_goal(produceAndEatCake, prepareCake).
   super_goal(sellCake, takePayment).
   super_goal(produceAndEatCake, eatCake).
   super_goal(prepareCake, mixIngredients).
   super_goal(produceAndEatCake, sellCake).
   super_goal(sellCake, deliverCake).
   super_goal(eatCake, giveToMySon).
   super_goal(sellCake, provideMoney).
   super_goal(eatCake, eatMyself).

   // ** Rules
   mplayers(M,S,V) :- .count(committed(_,M,S),V).
   well_formed(S) :- 
      (mission_accomplished(S,mBaker) | not mission_accomplished(S,mBaker) & mplayers(mBaker,S,VmBaker) & VmBaker >= 1 & VmBaker <= 1) &
      (mission_accomplished(S,mCustomer) | not mission_accomplished(S,mCustomer) & mplayers(mCustomer,S,VmCustomer) & VmCustomer >= 1 & VmCustomer <= 1) &
      (mission_accomplished(S,mApprentice) | not mission_accomplished(S,mApprentice) & mplayers(mApprentice,S,VmApprentice) & VmApprentice >= 1 & VmApprentice <= 1).
   is_finished(S) :- satisfied(S,produceAndEatCake).
   mission_accomplished(S,M) :- .findall(Goal, mission_goal(M,Goal), MissionGoals) & all_satisfied(S,MissionGoals).
   all_satisfied(_,[]).
   all_satisfied(S,[G|T]) :- satisfied(S,G) & all_satisfied(S,T).
   any_satisfied(S,[G|_]) :- satisfied(S,G).
   any_satisfied(S,[G|T]) :- not satisfied(S,G) & any_satisfied(S,T).

   // enabled goals (i.e. dependence between goals)
   enabled(S,G) :- goal(_, G,  dep(or,PCG), Type, NP, _) & NP \== 0 & any_satisfied(S,PCG).
   enabled(S,G) :- goal(_, G, dep(and,PCG), Type, NP, _) & Type \== reporting & Type \== treatment & NP \== 0 & all_satisfied(S,PCG).
   enabled(S,G) :- goal(_, G, dep(and,PCG), reporting, NP, _) & NP \== 0 & all_satisfied(S,PCG) & request(Ag,M,R) & mission_report(M,R) & report_goal(R,G).
   enabled(S,G) :- goal(_, G, dep(or,PCG), reporting, NP, _) & NP \== 0 & any_satisfied(S,PCG) & request(Ag,M,R) & mission_report(M,R) & report_goal(R,G).
   super_satisfied(S,G) :- super_goal(SG,G) & satisfied(S,SG).

   // ** Norms

   // --- Properties check ---
   norm mission_left:  
           leaved_mission(Agt,M,S) &
           not mission_accomplished(S,M)
        -> fail(mission_left(Agt,M,S)).
   norm ach_not_enabled_goal:  
           done(S,G,Agt) &
           mission_goal(M,G) &
           not mission_accomplished(S,M) &
           not enabled(S,G)
        -> fail(ach_not_enabled_goal(S,G,Agt)).
   norm ach_not_committed_goal:  
           done(S,G,Agt) &
           .findall(M, mission_goal(M,G) &
           (committed(Agt,M,S) | mission_accomplished(S,M)), [])
        -> fail(ach_not_committed_goal(S,G,Agt)).
   norm mission_permission:  
           committed(Agt,M,S) &
           not (mission_role(M,R) &
           responsible(Gr,S) &
           fplay(Agt,R,Gr))
        -> fail(mission_permission(Agt,M,S)).
   norm mission_cardinality:  
           scheme_id(S) &
           mission_cardinality(M,_,MMax) &
           mplayers(M,S,MP) &
           MP > MMax
        -> fail(mission_cardinality(M,S,MP,MMax)).

   // --- Reports ---
   norm request_invalid_context:
           request(Ag,M,R) &
           report(R,C) &
           not C
        -> fail(request_invalid_context(Ag,M,R,C)).
   norm request_agent_not_allowed:
           request(Ag,M1,R) &
           report(R,_) &
           treatment(T,R) &
           mission_treatment(M,T) &
           not committed(Ag,M,_)
        -> fail(request_agent_not_allowed(Ag,M1,R)).

   // agents are obliged to fulfill their enabled goals
   norm ngoal: 
           committed(A,M,S) & mission_goal(M,G) & 
           ((goal(_,G,_,achievement,_,D) & What = satisfied(S,G)) | 
            (goal(_,G,_,performance,_,D) & What = done(S,G,A))) &
           well_formed(S) & 
           not satisfied(S,G) & 
           not super_satisfied(S,G)
        -> obligation(A,enabled(S,G),What,`now` + D).

   // agents are obliged to provide reports if requested
   norm nreport: 
           committed(A,M,S) & mission_report(M,R) & report_goal(R,G) & 
           goal(_,G,_,reporting,_,D) & What = reported(S,G,R) & 
           well_formed(S) & 
           not satisfied(S,G) & 
           not super_satisfied(S,G) 
        -> obligation(A,enabled(S,G),What,`now` + D).

} // end of scheme cake_sch

} // end of organisation cake
